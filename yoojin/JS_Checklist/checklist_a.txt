1. 
전역변수 - global variable
지역변수 - local variable 

전역변수는 함수 밖에서 선언되는 변수이자 어디서든 사용이 가능하다
지역변수는 함수 안에서 선언되는 변수라서 함수밖에 불러오려고하면 에러/undefined가 뜰 수 있다

let engine = false

function on() {
 let engine = true;
 return engine
}

console.log(on()) // 결과값은 true
console.log(engine) // 결과값은 false 
---------------------------------------


3. ????


---------------------------------------

4.

(1) 
Arrays are useful when you need an ordered colletction of items and 
can call an element based on the number position of the item you want.

배열 - array => [1,2,3,'n','54',[2,3], {name : 'yj'}, 'string']

배열은 한변수 안에 많은 요소들을 담을 수 있는 컨테이너라고 생각합니다.

배열은 순서가 중요하고 0으로부터 안에있는 요소들에 순서를 카운트합니다.

객체 - object 
{ name : 'Max',
  age : 25,
  likes : ['puppy', 'cat', 'cake', 'music']
}
객체도 많은 데이터를 담을 수 있는 컨테이너지만 배열과 다른 점이:
- 순서 중요하지 않고 
- key : value 가있어서 더 자세한 내용들을 갖고있습니다. 
key = 이름 
value = key에 들어갈 값

(2)
    "배열에서 인덱스를 사용해야하는 순간은 언제일까요?"
We use the index of an array when we want to specify the item you want to change
or use 

(3) ** come back later

---------------------------------------

5.

1-4) is not a function

---------------------------------------

---------------------------------------

8.
(1) "객체와 배열은 각각 어느 순간에 사용해야할까요 key와 index를 중심으로 정의해보세요"


(2)
const hello = {a : 123, b : 'okay', c: ['d', 'e', 'f']}

        2-1) Object.values(hello) // [123, 'okay', ['d','e','f']]
	 
		2-2) Object.keys(hello) // ['a','b','c']

		2-3) Object.entries(hello) // ['a', 123]
                                    ['b', 'okay']
                                    ['c', ['d','e','f']]
    Object.values() returns an array of the values in the object 
    Obejct.key() returns an array of the keys in the object as strings
    Obejct.entries() retu multiple arrays of the key and value of the object 
---------------------------------------

9. 

 const users = [
    {id: 1, name: "pedro", age: 26 },
    {id: 2, name: "john", age: 22 },
    {id: 3, name: "jessica", age: 56 },
    {id: 4, name: "rio ferdinand", age: 126},
    {id: 5, name: "michael scott", age: 45}
];


filter: filters out the items you dont want and creates a new array of items you wanted.

Ex) Using filter() we're going to remove the user named "Pedro" 

const removeUser = (name) => { 
/* using an arrow function we named 'removeUser' 
we have a parameter 'name' which we can add an argument of who we want to remove*/

	const newUserArray = users.filter((user) => {
/* creating a new array we will use the filter() method to filter out the name we don't want 
as our object property */

		return user.name != name 
    // return all the user names that are not equal to the name I passed in the function parameter 
		})
	return newUserArray;
    // return newUserArray to removeUser function 
};

removeUser("pedro");

expected output: 
//{id: 2, name: "john", age: 22 },
//{id: 3, name: "jessica", age: 56 },
//{id: 4, name: "rio ferdinand", age: 126},
//{id: 5, name: "michael scott", age: 45}

-----------------------------------------------------------------------------------------------

reduce: allows you to reduce down an array into a singular value which is typically not an array but instead things like a number or a string

const array = [1, 5, 6, 4, 23, 4, 5, 2, 4]; 
//when using reduce() you need 2 values and an initial value 

const sum = array.reduce((sum, number) => { 
// sum being a accumulative value (represents all the numbers as a whole) and number representing each element in the existing array 
	return sum + number 
}, 0) //initial value is like the starting point 

console.log(sum); //54

-----------------------------------------------------------------------------------------------

sort: sorts out a list of items in an array into order

const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

expected output:
["Apple", "Banana", "Mango", "Orange"]

findIndex: returns index of the first array element that satisfies the the provided test function; else it returns -1


find: is like filter except it only returns a single element and when nothing is foudn
it returns 'undefined' 