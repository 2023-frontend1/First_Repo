먼저 우리는 html로 틀을 만들고 css로 옷을 입히며 js로 웹을 동적제어를 한다.
이때 웹페이지가 렌더링 되는 과정은 html parser가 html을 바탕으로 dom트리를 그린다.

웹 브라우저가 원본 HTML을 읽어들이고 Style을 입히고 대화형 페이지로 만들어서 뷰포트에 표시하기까지의 과정을 Criticial Rendering Path라고 한다
Criticial Rendering Path 를 대략 두 단계로 나눈다면, 다음과 같습니다.
> 브라우저는 읽어들인 문서를 파싱하여 어떠한 내용을 페이지에 렌더링 할지 결정하여 렌더트리를 생성합니다.
> 렌더트리를 바탕으로 실제로 렌더링 합니다.
이때 랜더트리는 돔과 cssom이라는 모델을 통해 생성됨.
CSSOM(CSS Object Model)은 CSS 객체 모델로 자바스크립트가 CSS를 동적으로 조작할 수 있게 해준다. >>  HTML 대신 CSS가 대상인 DOM이라고 할 수있다.
DOM은 Document Object Model으로 XML이나 HTML 문서에 접근하기 위한 인터페이스이다.

DOM 트리와 CSSOM 트리가 결합되어 Render Tree가 생성

"DOM은 원본 HTMl을 통해 만들어진 객체 기반의 표현 방식" HTML 문서의 내용과 구조가 객체 모델 로 변환이 되었다.

dom와 cssom 차이
<!doctype html>
<html land="ko">
  <head>
    <title>My first web page</title>
  </head>
  <body>
    <h1>Hello, world!</h1>
    <p style="display: none;">How are you?</p>
  </body>
</html>

DOM
html
ㄴhead
  ㄴtitle
    ㄴMy first web page
body
ㄴh1
  ㄴHello, world!
    ㄴp
      ㄴHow are you?

CSSOM
html
ㄴhead
  ㄴtitle
    ㄴMy first web page
body
ㄴh1
  ㄴHello, world!
display:none 이 적용된 <p>는 CSSOM에선 그려지지 않습니다!

원래는 jquery를 통해 DOM을 효율적으로 조작할수 있었으나, 웹페이지가 아닌! 웹 APPLICATION이 규모가 커져서! js의 파일이 커져 통제가 어려워짐.

>> 그래서 나타난것이 REACT와 .js같은 SPA라이브러리다.

기존에는 페이지 간 이동 시 HTML, CSS, Javascript 파일 전부를 서버와 주고 받았기 때문에 속도가 느렸다. 왜? 전부를 한꺼번에 다 옮기려 하니까 

반면 Single Page Application은 필요한 파일들을 최초 1회만 다운로드 합니다. 이후 새로운 페이지 요청 시 페이지 업데이트에 필요한 데이터만 서버로 부터 전달받아 DOM을 조작합니다.
즉 처음에 다 받은후 그 후에는 업데이트에 필 요 한! 데이터만 받아서 조작을 하기에 서버에서 주고받는 데이터 양이 줄었다!
>> 초기 구동이 느림(상대적) , SEO문제가 있다!  index.html이 하나뿐이기 때문에 SEO에 불리하다는 점 노출을 적게하니까. 하나라서

그래서 SPA가 가능하고, REACT가 주목 받게 된 것이 버츄얼 돔 때문.

React에는 state 와 props 라는 개념이 있다.  화면에서 변하는 값을 의미함!

https://www.youtube.com/watch?v=BYbgopx44vo

버츄얼 돔은 그래서 왜 좋은가? 
DOM 조작의 실제 문제는 각 조작이 레이아웃 변화, 트리 변화와 렌더링을 일으킨다는 것 >> 예를 들어 여러분이 30개의 노드를 수정하면 그 뜻은 30번 레이아웃 재계산과 30번 리렌더링을 하게됨

VDOM은 변화가 일어나면 오프라인 DOM 트리에 적용시킵니다. 이 DOM트리는 렌더링도 되지 않기 때문에 연산 비용이 적은 편입니다.  > 렌더링이 실제로 안되니까! > 연산이 끝나면 1번만 실제 dom에 던진다
즉 연산의 횟수가 줄어드는것이다.
그니까 그만큼의 리소스를 줄일 수 있다는것.




리액트는 자바스크립트 라이브러리다.

상태값이 변경되거나 부모가 재렌더링 할때마다 UI를 자동으로 업데이트 해주는 JS라이브러리다.

이때 업데이트를 가상 DOM을 사용해 변경된 부분만을 업데이트 해주는 구조를 사용한다.

이때 가상돔이란 실제 DOM이아닌 가상의 환경에 DOM을 생성하는것이고, 리액트는 이곳의 변경을 통해 실제 DOM에 변경된 부분만 업데이트하는것이다.

리액트는 2가지 단계를 통해서 렌더링를 진행하는데, 첫번째는 렌더 두번째는 커밋 단계이다.

 렌더 단게는  화면에 그릴 것을 파악하는 단계이고 커밋단계는 파악한 것들을 적용 하는 단계이다.

 리액트가 렌더링 할 경우는 크게 2가지인데 
  1) 사용자가 페이지에 처음 방문했을때 > 초기렌더 
  2) 상태가 업데이트 되었을때 > 리렌더

이때 초기 단계의 랜더에서는 render()메서드의 루트 컴포넌트를 호출한다
리렌더에서의 렌더는 상태 업데이트가 발생한 컴포넌트를 호출한다. 

커밋단계 또한 크게 2가지로 나누어 보면
  1) 초기 렌더 에서의 커밋
  2) 리렌더에서의 커밋
이때 초기 렌더에서의 커밋은 랜더 단계에서 파악한 DOM 노드를 실제 DOM에 반영한다.
리렌더에서의 커밋은 렌더간 발생한 변경사항 (가상DOM에서의 변경사항)을 DOM에 반영한다.
이때 적용하는 것은 DOM노드를 CRUD하여 새로운 컴포넌트 트리와 동기화 하는 과정이다. 즉, DOM 조작이 발생하면 변경된 노드만 파악하여 변경한다는것.

리액트의 장단점에 대해 이야기 하기 전에 특징에 대해 먼저 알아보자.

리액트는 선언적이다. 
  이는 리액트가 대화형 UI를 작성하기에 유리하다는 것으로, 데이터가 변경되었을때 효율적인 렌더링을 수행할 수 있게 한다.
  선언적 프로그래밍이라는 것은 어떻게 보다 무엇을 나타내야 하는지를 보여주는 것으로 가독성과 유지보수 측면에서 좋다.
  또한 변수의 사용량이 줄어들고 이로인해 코드를 읽을때 예측 가능하고 디버깅이 쉽다.
  선언적 프로그래밍인 리액트는 내부적인 구현을 다르게 만들어 웹, react-Native에서도 사용가능하다 즉, 이는 재사용되기 쉽다는 것이다.

리액트는 다른 프레임워크나 라이브러리와도 병행하여 사용할 수 있다.
  이는 리액트가 이미 개발이 완료된 프로젝트에서도 적용할 수 있는 확장성을 의미한다.

그렇다면 단점에는 무엇이 있을까.
리액트는 로딩시간이 길고, 데이터 모델링, 라우팅등의 기능 지원이 되지 않는다는 단점이 있다.


